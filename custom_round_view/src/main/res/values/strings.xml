<resources>
    <string name="app_name">custom_round_view</string>
    <string name="message_xfermode_1">Xfermode是什么呢？\n
Xfermode称为图形混合模式也被称为过渡模式，把两个图形混合成一张图。\n

Xfermode 实现类有AvoidXfermode，PixelXorXfermode，PorterDuffXfermode，但是AvoidXfermode，PixelXorXfermode都已经被标识不推荐使用了，所以就只有PorterDuffXfermode一个实现类。PorterDuffXfermode用于图形合成时的图像过渡模式计算。
前两个实现类在API level 16被标记为Deprecated了（因为不支持硬件加速），用也可以，但是需要关闭硬件加速，高版本api默认打开硬件加速，如果需要关闭硬件加速，无法发挥OpenGLes的作用，也就无法充分利用GPU绘图能力，有关硬件加速请看https://developer.android.com/guide/topics/graphics/hardware-accel；
PorterDuff.Mode它是将所绘制的图形的像素与Canvas中对应位置的像素按照一定规则进行混合,形成新的像素值,从而更新Canvas中最终的像素颜色值.\n
PorterDuff.Mode共有18种\n
Android 中使用 图层混合模式常见的地方有三种:\n

1. 组合渲染ComposeShader (详见: Android Paint总结)\n

2. 画笔: Paint.setXfermode()\n

3. 颜色过滤器: PorterDuffColorFilter\n

</string>

    <string name="message_xfermode_2">
每一个图层混合模式代表一种规则,根据每种规则计算混合之后的透明通道值和颜色值
使用图层混合模式有几个需要注意的点:\n\n

1. 图层混合模式仅作用于src源图像\n

意思是:以下面谷歌的demo中的第一个为例使用的模式为PorterDuff.Mode.CLEAR
,源图像src为矩形图 目标图为圆形图dst,PorterDuff.Mode.CLEAR表示清除所有颜色值和透明通道,我们从效果可以看到,目标图dst只有与源图像src相交的地方才会有影响\n\n

2. 禁用硬件加速\n

原因: 在Android api 14之后,图层混合的有些api是不支持硬件加速的,系统的硬件加速是默认开启的,所以在使用图层混合模式之前,禁用掉硬件加速 ,方式如下:\n

//禁止硬件加速\n
setLayerType(View.LAYER_TYPE_SOFTWARE, null);\n\n


3. 离屏绘制\n

原因: 在不采用离屏绘制的情况下,控件的背景会影响图层混合模式的计算结果,导致得到期望之外的效果\n
我们看下使用/不使用 离屏绘制的区别:\n\n

    </string>

    <string name="message_xfermode_3">

通过使用离屏绘制(离屏缓冲),把要绘制的内容单独绘制在缓冲层,保证Xfermode的使用不会出现错误的结果\n

离屏绘制有两种使用方式,一般使用第一种方式就足够了:\n\n

Canvas.saveLayer() 可以做短时的离屏绘制,在绘制之前保存 ,绘制之后结束,使用方式如下:\n

 int saveId= canvas.saveLayer(0, 0, width, height, Canvas.ALL_SAVE_FLAG);\n
                canvas.translate(x, y);\n
                canvas.drawBitmap(mDstB, 0, 0, paint);//绘制操作\n
                paint.setXfermode(xfermode);//设置xfermode\n
                canvas.drawBitmap(mSrcB, 0, 0, paint);//绘制操作\n
                paint.setXfermode(null); //用完清除\n
                canvas.restoreToCount(saveId);//图层恢复\n\n
View.setLayerType() 直接把整个View都绘制在离屏缓冲中,使用如下:\n\n

setLayerType(LAYER_TYPE_HARDWARE,paint);//使用GPU缓冲\n
setLayerType(LAYER_TYPE_SOFTWARE,paint);//使用一个Bitmap缓冲\n

    </string>

    <string name="message_xfermode_4">
        两个图形一圆一方通过设置不同的模式会产生不同的组合效果，\n

在API中Android为我们提供了18种（比上图多了两种ADD和OVERLAY）模式：　\n\n

ADD:                饱和相加,对图像饱和度进行相加,不常用\n
CLEAR:             清除图像\n
DARKEN:          变暗,较深的颜色覆盖较浅的颜色，若两者深浅程度相同则混合\n
DST:                只显示目标图像\n
DST_ATOP:      在源图像和目标图像，相交的地方绘制【目标图像】，  不相交的地方绘制【源图像】，相交处的效果受到源图像和目标图像alpha的影响\n
DST_IN:           只在源图像和目标图像相交的地方绘制【目标图像】，绘制效果受到源图像对应地方透明度影响\n
DST_OUT:        只在源图像和目标图像不相交的地方绘制【目标图像】，在相交的地方根据源图像的alpha进行过滤，源图像完全不透明则完全过滤，完全透明则不过滤\n
DST_OVER:        将目标图像放在源图像上方\n
LIGHTEN:           变亮，与DARKEN相反，DARKEN和LIGHTEN生成的图像结果与Android对颜色值深浅的定义有关\n
MULTIPLY:        正片叠底，源图像素颜色值乘以目标图像素颜色值除以255得到混合后图像像素颜色值\n
OVERLAY:        叠加\n
SCREEN:         滤色，色调均和,保留两个图层中较白的部分，较暗的部分被遮盖\n
SRC:                只显示源图像\n
SRC_ATOP:        在源图像和目标图像相交的地方绘制【源图像】，在不相交的地方绘制【目标图像】，相交处的效果受到源图像和目标图像alpha的影响\n
SRC_IN:        只在源图像和目标图像相交的地方绘制【源图像】\n
SRC_OUT:    只在源图像和目标图像不相交的地方绘制【源图像】，相交的地方根据目标图像的对应地方的alpha进行过滤，目标图像完全不透明则完全过滤，完全透明则不过滤\n
SRC_OVER:    将源图像放在目标图像上方\n
XOR:            在源图像和目标图像相交的地方之外绘制它们，在相交的地方受到对应alpha和色值影响，如果完全不透明则相交处完全不绘制\n\n

    </string>



    <string name="message_clip_path_1">
      在Android自定义View使用绘图的裁剪功能的时候,我们最好manifest中的<application/> 或者<activity/>或者<fragment/>标签中添加如下属性\n\n
        android:hardwareAccelerated="false"\n\n
因为裁剪功能是不支持硬件加速的.没有设置的话,有可能绘图裁剪的效果出不来;\n

Android Canvas原生api裁剪方法中clipRect和clipPath方法中，有的不传递Region.Op参数,其实在它的内部默认Region.Op.INTERSECT.这点可以查看他们的api可知;\n
    public boolean clipRect(@NonNull RectF rect) {\n
        return native_clipRect(mNativeCanvasWrapper, rect.left, rect.top, rect.right,\n
           rect.bottom, Region.Op.INTERSECT.nativeInt);\n
    }\n

    public boolean clipPath(@NonNull Path path) {\n
        return clipPath(path, Region.Op.INTERSECT);\n
    }\n\n
Region.Op是一个枚举类型，总共有如下几个枚举对象;\n\n
    // the native values for these must match up with the enum in SkRegion.h\n
    public enum Op {\n
        DIFFERENCE(0),\n
        INTERSECT(1),\n
        UNION(2),\n
        XOR(3),\n
        REVERSE_DIFFERENCE(4),\n
        REPLACE(5);\n

        Op(int nativeInt) {\n
            this.nativeInt = nativeInt;\n
        }\n

        /**\n
         * @hide\n
         */\n
        public final int nativeInt;\n
    }\n\n
那么他们什么含义呢？ 形象的举个例子\n\n

A:表示第一个裁剪的形状;\n

B:表示第二次裁剪的形状;\n

1.    Region.Op.DIFFERENCE ：是A形状中不同于B的部分显示出来\n
2.    Region.Op.REPLACE：是只显示B的形状\n
3.    Region.Op.REVERSE_DIFFERENCE ：是B形状中不同于A的部分显示出来，这是没有设置时候默认的\n
4.    Region.Op.INTERSECT：是A和B交集的形状\n
5.    Region.Op.UNION：是A和B的全集\n
6.    Region.Op.XOR：是全集形状减去交集形状之后的部分\n

下面通过代码示例逐个验证：\n\n
              canvas.save();\n
            canvas.translate(10, 10);\n
            //画笔颜色设置为浅蓝色\n
            mPaint.setColor(Color.parseColor("#D4E9FA"));\n
            //画笔画一个矩形\n
            canvas.drawRect(new RectF(0, 0, 300, 300), mPaint);\n
            //画笔画一个圆形\n
            canvas.drawCircle(300, 150, 150, mPaint);\n

            //上面的画的一个矩形和圆形是属于浅蓝色的底层背景，是为了便于观察效果的，没有什么其他含义\n
            //下面开始真正的clip操作\n
            //1.画布裁剪一个矩形\n
            canvas.clipRect(new RectF(0, 0, 300, 300));//第一个裁剪一个形状相当于A\n
            //2.画布裁剪一个圆形\n
            Path mPath = new Path();\n
            mPath.addCircle(300, 150, 150, Path.Direction.CCW);\n
            //2.1这里只是改变第二个参数Region.Op.来观察效果\n
            canvas.clipPath(mPath, Region.Op.DIFFERENCE);//第二个裁剪一个形状相当于B\n
            //3.裁剪完之后,画一个最大长宽的红色矩形观察效果\n
            //画笔颜色设置为浅红色\n
            mPaint.setColor(Color.parseColor("#FF4081"));\n
            canvas.drawRect(new RectF(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE), mPaint);\n
            canvas.restore();\n\n

    </string>
</resources>